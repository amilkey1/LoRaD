-180992.9603,
-180969.0212,
-181063.4758,
-181044.8184,
-180922.5511,
-181103.6756,
-180923.9818,
-180926.889,
-180926.7748,
-180932.6694,
-180942.9246,
-181050.5058,
-181000.6368,)
lorad <- c(-180950.338,
-180959.2968,
-180918.6291,
-180915.9857,
-181006.6747,
-180958.9215,
-180992.9603,
-180969.0212,
-181063.4758,
-181044.8184,
-180922.5511,
-181103.6756,
-180923.9818,
-180926.889,
-180926.7748,
-180932.6694,
-180942.9246,
-181050.5058,
-181000.6368)
rep <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19)
diff <- c(48.671116,
53.660582,
12.385538,
9.60574,
97.255406,
48.799178,
82.594198,
58.026681,
151.804815,
132.080773,
7.58922,
188.072178,
-1.863145,
0.819221,
-0.389042,
1.528454,
1.745323,
101.4297,
39.733048,)
par(mar=c(5,4,4,4)+0.3)
plot(rep, smc, pch=16, col=2)
par(new=TRUE)
plot(rep, lorad, pch=17, col=3, axes=FALSE, xlab="", ylab="")
axis(side=4, at=pretty(range(y2)))
library(LoRaD)
remove.packages("LoRaD")
#
library(diversitree)
## subdivide our plot and set margins
par(mfrow=c(1,2),mar=c(0.1,1.1,2.1,1.1))
## panel a)
## set BiSSE parameter values
pars<-setNames(
c(0.1,0.3,0.01,0.01,0.03,0.03), c("lambda0","lambda1","mu0,","mu1",
"q01","q10"))
pars
## simulate BiSSE tree
phy.bisse<-tree.bisse(pars,max.taxa=80,x0=0)
h<-history.from.sim.discrete(phy.bisse,0:1) ## plot simulated tree
plot(h,phy.bisse,show.tip.label=FALSE, cols=c("black","grey"),cex=0.7)
## add panel label
mtext("(a)",lwd=1,adj=0,font=1)
## panel b)
## set non-BiSSE simulation parameter values
pars<-setNames(c(0.2,0.2,0.01,0.01,0.03,0.03), c("lambda0","lambda1","mu0","mu1", "q01","q10"))
pars
## simulate state-independent diversification
phy.nonbisse<-tree.bisse(pars,max.taxa=80,x0=0)
h<-history.from.sim.discrete(phy.nonbisse,0:1) ## plot results
plot(h,phy.nonbisse,show.tip.label=FALSE, cols=c("black","gray"),cex=0.7) ## add panel label
mtext("(b)",lwd=1,adj=0,font=1)
library(geiger)
library(phytools)
gt<-read.tree("grunts.phy")
print(gt,printlen=2)
gd<-read.csv("grunts.csv",row.names=1, stringsAsFactors=TRUE)
head(gd)
## extract habitat data
hab<-gd[,1]
## set names
names(hab) <- rownames(gd)
## plot our tree
plotTree(gt, ftype="i", fsize=0.7, offset=0.5)
## add tip labels
tiplabels(pie=to.matrix(hab,0:1)[gt$tip.label,], piecol=c("white", "black"), cex=0.4)
## create legend
legend("bottomleft",c("non-reef","reef"), pch=21,pt.cex=1.6, cex=0.8,bty="n", pt.bg=c("white","black"))
## make BiSSE likelihood function
bisse.model<-make.bisse(gt,hab)
## find reasonable parameter values for ## optimization
p<-starting.point.bisse(gt)
p # MLE values for parameters
fit.bd(gt)
## optimize BiSSE model
bisse.mle<-find.mle(bisse.model,p)
bisse.mle # MLE 2x as high as speciation rate of non-reef fish
# fit null model too - constrained likelihood function
## create constrained null model
bissenull.model<-constrain(bisse.model, lambda1~lambda0,mu1~mu0)
## optimize null model
bissenull.mle<-find.mle(bissenull.model, p[c(-2,-4)])
# print fitted model coefficients & likelihood
coef(bissenull.mle)
logLik(bissenull.mle)
## run likelihood-ratio test
bisseAnova<-anova(bisse.mle, null=bissenull.mle)
bisseAnova
aicw(setNames(bisseAnova$AIC, rownames(bisseAnova)))
# weak support for BiSSE model
# 11.2.2 Analyzing a BiSSE model using Bayesian MCMC
prior<-make.prior.exponential(1/(2*0.4))
prior
## run Bayesian MCMC
bisse.mcmc<-mcmc(bisse.model,bisse.mle$par, nsteps=1000,prior=prior,w=0.1, print.every=100)
#  visualize posterior distribution of 2 different params in our model
## subdivide plot and set margins
par(mfrow=c(1,2),mar=c(5.1,4.1,3.1,2.1)) ## set colors for plotting
col<-setNames(c("blue", "red"), c("non-reef","reef"))
## create graph of posterior sample for lambda
profiles.plot(bisse.mcmc[,c("lambda0","lambda1")], col.line=col,las=1,bty="n", xlab=expression(lambda),cex.axis=0.7)
x <- rbeta(100000,4,12)
y <- ifelse(x <= 0.5,x,1-x)
plot(density(y), xlim=c(0, 0.5))
curve(dbeta(x,4,12)-dbeta(1-x,4,12),col="red", add=T)
library(bridgesampling)
### generate data ###
set.seed(12345)
mu <- 0
tau2 <- 0.5
sigma2 <- 1
n <- 20
theta <- rnorm(n, mu, sqrt(tau2))
### set prior parameters ###
mu0 <- 0
tau20 <- 1
alpha <- 1
beta <- 1
library(R2jags)
# H0: mu = 0
getSamplesModelH0 <- function(data, niter = 52000, nburnin = 2000, nchains = 3) {
model <- "
model {
for (i in 1:n) {
theta[i] ~ dnorm(0, invTau2)
y[i] ~ dnorm(theta[i], 1/sigma2)
}
invTau2 ~ dgamma(alpha, beta)
tau2 <- 1/invTau2
}"
s <- jags(data, parameters.to.save = c("theta", "invTau2"),
model.file = textConnection(model),
n.chains = nchains, n.iter = niter,
n.burnin = nburnin, n.thin = 1)
return(s)
}
# H1: mu != 0
getSamplesModelH1 <- function(data, niter = 52000, nburnin = 2000,
nchains = 3) {
model <- "
model {
for (i in 1:n) {
theta[i] ~ dnorm(mu, invTau2)
y[i] ~ dnorm(theta[i], 1/sigma2)
}
mu ~ dnorm(mu0, 1/tau20)
invTau2 ~ dgamma(alpha, beta)
tau2 <- 1/invTau2
}"
s <- jags(data, parameters.to.save = c("theta", "mu", "invTau2"),
model.file = textConnection(model),
n.chains = nchains, n.iter = niter,
n.burnin = nburnin, n.thin = 1)
return(s)
}
# create data lists for JAGS
data_H0 <- list(y = y, n = length(y), alpha = alpha, beta = beta, sigma2 = sigma2)
data_H1 <- list(y = y, n = length(y), mu0 = mu0, tau20 = tau20, alpha = alpha,
beta = beta, sigma2 = sigma2)
# fit models
samples_H0 <- getSamplesModelH0(data_H0)
# specify parameter bounds H0
cn <- colnames(samples_H0$BUGSoutput$sims.matrix)
cn <- cn[cn != "deviance"]
lb_H0 <- rep(-Inf, length(cn))
ub_H0 <- rep(Inf, length(cn))
names(lb_H0) <- names(ub_H0) <- cn
lb_H0[[ "invTau2" ]] <- 0
# specify parameter bounds H1
cn <- colnames(samples_H1$BUGSoutput$sims.matrix)
cn <- cn[cn != "deviance"]
lb_H1 <- rep(-Inf, length(cn))
ub_H1 <- rep(Inf, length(cn))
names(lb_H1) <- names(ub_H1) <- cn
samples_H1 <- getSamplesModelH1(data_H1)
log_posterior_H0 <- function(samples.row, data) {
mu <- 0
invTau2 <- samples.row[[ "invTau2" ]]
theta <- samples.row[ paste0("theta[", seq_along(data$y), "]") ]
sum(dnorm(data$y, theta, data$sigma2, log = TRUE)) +
sum(dnorm(theta, mu, 1/sqrt(invTau2), log = TRUE)) +
dgamma(invTau2, data$alpha, data$beta, log = TRUE)
}
log_posterior_H1 <- function(samples.row, data) {
l
log_posterior_H1 <- function(samples.row, data) {
mu <- samples.row[[ "mu" ]]
invTau2 <- samples.row[[ "invTau2" ]]
theta <- samples.row[ paste0("theta[", seq_along(data$y), "]") ]
sum(dnorm(data$y, theta, data$sigma2, log = TRUE)) +
sum(dnorm(theta, mu, 1/sqrt(invTau2), log = TRUE)) +
dnorm(mu, data$mu0, sqrt(data$tau20), log = TRUE) +
dgamma(invTau2, data$alpha, data$beta, log = TRUE)
}
# specify parameter bounds H0
cn <- colnames(samples_H0$BUGSoutput$sims.matrix)
cn <- cn[cn != "deviance"]
lb_H0 <- rep(-Inf, length(cn))
ub_H0 <- rep(Inf, length(cn))
names(lb_H0) <- names(ub_H0) <- cn
lb_H0[[ "invTau2" ]] <- 0
# specify parameter bounds H1
cn <- colnames(samples_H1$BUGSoutput$sims.matrix)
cn <- cn[cn != "deviance"]
lb_H1 <- rep(-Inf, length(cn))
ub_H1 <- rep(Inf, length(cn))
names(lb_H1) <- names(ub_H1) <- cn
lb_H1[[ "invTau2" ]] <- 0
# compute log marginal likelihood via bridge sampling for H0
H0.bridge <- bridge_sampler(samples = samples_H0, data = data_H0,
log_posterior = log_posterior_H0, lb = lb_H0,
ub = ub_H0, silent = TRUE)
# compute log marginal likelihood via bridge sampling for H1
H1.bridge <- bridge_sampler(samples = samples_H1, data = data_H1,
log_posterior = log_posterior_H1, lb = lb_H1,
ub = ub_H1, silent = TRUE)
print(H0.bridge)
print(H1.bridge)
setwd("/Users/analisamilkey/Desktop/bridge-sampling")
### generate data ###
set.seed(12345)
mu <- 0
tau2 <- 0.5
sigma2 <- 1
n <- 20
theta <- rnorm(n, mu, sqrt(tau2))
y <- rnorm(n, theta, sqrt(sigma2))
### set prior parameters ###
mu0 <- 0
tau20 <- 1
alpha <- 1
beta <- 1
### generate data ###
set.seed(12345)
mu <- 0
tau2 <- 0.5
sigma2 <- 1
n <- 20
theta <- rnorm(n, mu, sqrt(tau2))
y <- rnorm(n, theta, sqrt(sigma2))
### set prior parameters ###
mu0 <- 0
tau20 <- 1
alpha <- 1
beta <- 1
library(R2jags)
# H0: mu = 0
getSamplesModelH0 <- function(data, niter = 52000, nburnin = 2000, nchains = 3) {
model <- "
model {
for (i in 1:n) {
theta[i] ~ dnorm(0, invTau2)
y[i] ~ dnorm(theta[i], 1/sigma2)
}
invTau2 ~ dgamma(alpha, beta)
tau2 <- 1/invTau2
}"
s <- jags(data, parameters.to.save = c("theta", "invTau2"),
model.file = textConnection(model),
n.chains = nchains, n.iter = niter,
n.burnin = nburnin, n.thin = 1)
return(s)
}
# H1: mu != 0
getSamplesModelH1 <- function(data, niter = 52000, nburnin = 2000,
nchains = 3) {
model <- "
model {
for (i in 1:n) {
theta[i] ~ dnorm(mu, invTau2)
y[i] ~ dnorm(theta[i], 1/sigma2)
}
mu ~ dnorm(mu0, 1/tau20)
invTau2 ~ dgamma(alpha, beta)
tau2 <- 1/invTau2
}"
s <- jags(data, parameters.to.save = c("theta", "mu", "invTau2"),
model.file = textConnection(model),
n.chains = nchains, n.iter = niter,
n.burnin = nburnin, n.thin = 1)
return(s)
}
# create data lists for JAGS
data_H0 <- list(y = y, n = length(y), alpha = alpha, beta = beta, sigma2 = sigma2)
data_H1 <- list(y = y, n = length(y), mu0 = mu0, tau20 = tau20, alpha = alpha,
beta = beta, sigma2 = sigma2)
# fit models
samples_H0 <- getSamplesModelH0(data_H0)
samples_H1 <- getSamplesModelH1(data_H1)
log_posterior_H0 <- function(samples.row, data) {
mu <- 0
invTau2 <- samples.row[[ "invTau2" ]]
theta <- samples.row[ paste0("theta[", seq_along(data$y), "]") ]
sum(dnorm(data$y, theta, data$sigma2, log = TRUE)) +
sum(dnorm(theta, mu, 1/sqrt(invTau2), log = TRUE)) +
dgamma(invTau2, data$alpha, data$beta, log = TRUE)
}
log_posterior_H1 <- function(samples.row, data) {
mu <- samples.row[[ "mu" ]]
invTau2 <- samples.row[[ "invTau2" ]]
theta <- samples.row[ paste0("theta[", seq_along(data$y), "]") ]
sum(dnorm(data$y, theta, data$sigma2, log = TRUE)) +
sum(dnorm(theta, mu, 1/sqrt(invTau2), log = TRUE)) +
dnorm(mu, data$mu0, sqrt(data$tau20), log = TRUE) +
dgamma(invTau2, data$alpha, data$beta, log = TRUE)
}
# specify parameter bounds H0
cn <- colnames(samples_H0$BUGSoutput$sims.matrix)
cn <- cn[cn != "deviance"]
lb_H0 <- rep(-Inf, length(cn))
ub_H0 <- rep(Inf, length(cn))
names(lb_H0) <- names(ub_H0) <- cn
lb_H0[[ "invTau2" ]] <- 0
# specify parameter bounds H1
cn <- colnames(samples_H1$BUGSoutput$sims.matrix)
cn <- cn[cn != "deviance"]
lb_H1 <- rep(-Inf, length(cn))
ub_H1 <- rep(Inf, length(cn))
names(lb_H1) <- names(ub_H1) <- cn
lb_H1[[ "invTau2" ]] <- 0
# compute log marginal likelihood via bridge sampling for H0
H0.bridge <- bridge_sampler(samples = samples_H0, data = data_H0,
log_posterior = log_posterior_H0, lb = lb_H0,
ub = ub_H0, silent = TRUE)
# compute log marginal likelihood via bridge sampling for H1
H1.bridge <- bridge_sampler(samples = samples_H1, data = data_H1,
log_posterior = log_posterior_H1, lb = lb_H1,
ub = ub_H1, silent = TRUE)
print(H0.bridge)
print(H1.bridge)
View(H1.bridge)
View(data_H0)
View(data_H1)
# save data files
write.csv(data_H0, "H0.csv", row.names=FALSE)
write.csv(data_H1, "H0.csv", row.names=FALSE)
write.csv(samples_H0, "H0_samples.csv", row.names=FALSE)
write.csv(samples_H1, "H1_samples.csv", row.names=FALSE)
View(samples_H0)
View(data_H1)
library(lorad)
params <- read.table('data_H0.csv', header=TRUE)
# save data files
write.csv(data_H0, "H0.csv", row.names=FALSE)
write.csv(data_H1, "H1.csv", row.names=FALSE)
library(lorad)
params <- read.table('H0.csv', header=TRUE)
View(data_H1)
View(samples_H1)
# compute log marginal likelihood via bridge sampling for H1
H1.bridge <- bridge_sampler(ssamplesH0.txt)
# compute log marginal likelihood via bridge sampling for H1
H1.bridge <- bridge_sampler(samplesH0.txt)
# library(lorad)
# params <- read.table('H0.csv', header=TRUE)
samplesH0 <- read.csv(samplesH0.txt)
# library(lorad)
# params <- read.table('H0.csv', header=TRUE)
samplesH0 <- read.csv('samplesH0.txt', header=TRUE)
# compute log marginal likelihood via bridge sampling for H1
H1.bridge <- bridge_sampler(samplesH0.txt)
# compute log marginal likelihood via bridge sampling for H1
H1.bridge <- bridge_sampler(samplesH0)
library(bridgesampling)
### generate data ###
set.seed(12345)
mu <- 0
tau2 <- 0.5
sigma2 <- 1
n <- 20
theta <- rnorm(n, mu, sqrt(tau2))
y <- rnorm(n, theta, sqrt(sigma2))
library(Matrix)
detach("package:Matrix", unload = TRUE)
library(bridgesampling)
install.packages("bridgesampling")
install.packages("bridgesampling")
library(bridgesampling)
setwd("/Users/analisamilkey/Documents/projects/LoRaD/LoRaD/bridge-sampling")
library(bridgesampling)
### generate data ###
set.seed(12345)
?rnorm
mu <- 0
tau2 <- 0.5
sigma2 <- 1
n <- 20
theta <- rnorm(n, mu, sqrt(tau2))
### set prior parameters ###
mu0 <- 0
tau20 <- 1
alpha <- 1
beta <- 1
library(rstan)
# models
stancodeH0 <- 'data {
int<lower=1> n; // number of observations
vector[n] y; // observations
real<lower=0> alpha;
real<lower=0> beta;
real<lower=0> sigma2;
}
parameters {
real<lower=0> tau2; // group-level variance
vector[n] theta; // participant effects
}
model {
target += inv_gamma_lpdf(tau2 | alpha, beta);
target += normal_lpdf(theta | 0, sqrt(tau2));
target += normal_lpdf(y | theta, sqrt(sigma2));
}
'
stancodeH1 <- 'data {
int<lower=1> n; // number of observations
vector[n] y; // observations
real mu0;
real<lower=0> tau20;
real<lower=0> alpha;
real<lower=0> beta;
real<lower=0> sigma2;
}
parameters {
real mu;
real<lower=0> tau2; // group-level variance
vector[n] theta; // participant effects
}
model {
target += normal_lpdf(mu | mu0, sqrt(tau20));
target += inv_gamma_lpdf(tau2 | alpha, beta);
target += normal_lpdf(theta | mu, sqrt(tau2));
target += normal_lpdf(y | theta, sqrt(sigma2));
}
'
# compile models
stanmodelH0 <- stan_model(model_code = stancodeH0, model_name="stanmodel")
stanmodelH1 <- stan_model(model_code = stancodeH1, model_name="stanmodel")
# fit models
stanfitH0 <- sampling(stanmodelH0, data = list(y = y, n = n,
alpha = alpha,
beta = beta,
sigma2 = sigma2),
iter = 50000, warmup = 1000, chains = 3, cores = 1)
stanfitH1 <- sampling(stanmodelH1, data = list(y = y, n = n,
mu0 = mu0,
tau20 = tau20,
alpha = alpha,
beta = beta,
sigma2 = sigma2),
iter = 50000, warmup = 1000, chains = 3, cores = 1)
# compute log marginal likelihood via bridge sampling for H0
H0.bridge <- bridge_sampler(stanfitH0, silent = TRUE)
# compute log marginal likelihood via bridge sampling for H1
H1.bridge <- bridge_sampler(stanfitH1, silent = TRUE)
print(H0.bridge)
print(H1.bridge)
# compute percentage errors
H0.error <- error_measures(H0.bridge)$percentage
H1.error <- error_measures(H1.bridge)$percentage
print(H0.error)
print(H1.error)
# compute Bayes factor
BF01 <- bf(H0.bridge, H1.bridge)
print(BF01)
# compute posterior model probabilities (assuming equal prior model probabilities)
post1 <- post_prob(H0.bridge, H1.bridge)
print(post1)
# compute posterior model probabilities (using user-specified prior model probabilities)
post2 <- post_prob(H0.bridge, H1.bridge, prior_prob = c(.6, .4))
print(post2)
paramsH0 <- data.frame(extract(stanfitH0, permuted=TRUE))
write.table(paramsH0, file="samplesH0.txt", sep="\t", row.names=FALSE)
paramsH1 <- data.frame(extract(stanfitH1, permuted=TRUE))
write.table(paramsH1, file="samplesH1.txt", sep="\t", row.names=FALSE)
library(lorad)
colspecH0 <- c("tau2"="unconstrained", "theta.1"="unconstrained", "theta.2"="unconstrained", "theta.3"="unconstrained", "theta.4"="unconstrained", "theta.5"="unconstrained", "theta.6"="unconstrained", "theta.7"="unconstrained", "theta.8"="unconstrained", "theta.9"="unconstrained", "theta.10"="unconstrained", "theta.11"="unconstrained", "theta.12"="unconstrained", "theta.13"="unconstrained", "theta.14"="unconstrained", "theta.15"="unconstrained", "theta.16"="unconstrained", "theta.17"="unconstrained", "theta.18"="unconstrained", "theta.19"="unconstrained", "theta.20"="unconstrained", "lp__"="posterior")
lorad_estimate(paramsH0, colspecH0, 0.5, "left", 0.1)
colspecH1 <- c("tau2"="unconstrained", "theta.1"="unconstrained", "theta.2"="unconstrained", "theta.3"="unconstrained", "theta.4"="unconstrained", "theta.5"="unconstrained", "theta.6"="unconstrained", "theta.7"="unconstrained", "theta.8"="unconstrained", "theta.9"="unconstrained", "theta.10"="unconstrained", "theta.11"="unconstrained", "theta.12"="unconstrained", "theta.13"="unconstrained", "theta.14"="unconstrained", "theta.15"="unconstrained", "theta.16"="unconstrained", "theta.17"="unconstrained", "theta.18"="unconstrained", "theta.19"="unconstrained", "theta.20"="unconstrained", "lp__"="posterior")
lorad_estimate(paramsH1, colspecH1, 0.5, "left", 0.1)
colspecH1 <- c("mu"="unconstrained", "tau2"="unconstrained", "theta.1"="unconstrained", "theta.2"="unconstrained", "theta.3"="unconstrained", "theta.4"="unconstrained", "theta.5"="unconstrained", "theta.6"="unconstrained", "theta.7"="unconstrained", "theta.8"="unconstrained", "theta.9"="unconstrained", "theta.10"="unconstrained", "theta.11"="unconstrained", "theta.12"="unconstrained", "theta.13"="unconstrained", "theta.14"="unconstrained", "theta.15"="unconstrained", "theta.16"="unconstrained", "theta.17"="unconstrained", "theta.18"="unconstrained", "theta.19"="unconstrained", "theta.20"="unconstrained", "lp__"="posterior")
lorad_estimate(paramsH1, colspecH1, 0.5, "left", 0.1)
